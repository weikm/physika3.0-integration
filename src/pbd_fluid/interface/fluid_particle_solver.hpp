/**
 * @file      : fluid_particle_solver.hpp
 * @author    : Yuege Xiong (candybear0714@163.com)
 * @date      : 2023-11-23
 * @brief     : This file declares the fluid solver which is designed to handle simulations of fluid material systems.
 *              The implementation is based on the paper "Unified particle physics for real-time applications" presented at TOG 2014.
 *              More specifically, the fluid material and friction handling described in Section 6 of the paper are the main focus of this solver.
 *
 *              This solver can be employed for simulations requiring realistic behavior of fluid materials (like sand, gravel, etc.)
 *              The file defines the FluidPhase enum, FluidComponent struct, and the FluidParticleSolver class which inherits from the base Solver class.
 *              Various methods for managing the fluid system such as initializing, resetting, stepping, attaching/detaching objects, etc. are also declared.
 *              A SolverConfig struct is provided for configuring simulation time parameters.
 *
 *              Use cases include, but are not limited to, game development, real-time physics simulations, CGI, etc.
 *              The simulation parameters, although tested and set to provide stable execution, can be modified according to the specific requirements of the application.
 *
 * @version   : 1.0
 */

#ifndef FLUID_PARTICLE_SOLVER_HPP
#define FLUID_PARTICLE_SOLVER_HPP

#include "framework/solver.hpp"

#include <stdlib.h>

#include <vector>
#include <vector_functions.h>

namespace Physika {
// forwar declaration
struct PBDFluidSimulateParams;

/**
 * @brief the phase of particles
 * Considering that the engine may have other multiple PBD solvers, the phase is used to distinguish the particles of different solvers.
 *
 * this solver is fluid solver, so the particle phase in this solver is FLUID or ELASTIC.
 */
enum class PBDFluidPhase
{
    FLUID    = 0,
    GRANULAR = 1,
    SOLID    = 2,
    ELASTIC  = 3,
};
/**
 * @brief the fluid component of the solver
 * When creating a fluid component, a cube-shaped particles are generated by default,
 *
 * it can be changed by setting m_host_pos and m_host_vel.
 * When apply a new scene, you should set the m_host_pos, m_host_vel and m_host_phase at the same time.
 */
struct PBDFluidComponent
{
    // host data(CPU data)
    /**
     * these data are used to initialize the granular component
     * they can be modified by the user.
     *
     * When modifying these data, you should comply with the following data layout methods
     */

    /**
     * data layout: x, y, z, mass
     * x, y, z are the position of particles in simulation
     * mass is the mass of particles in simulation
     */
    std::vector<float> m_host_pos;
    /**
     * data layout: x, y, z, 1
     * x, y, z are the velocity of particles in simulation
     * 1 is the phase of particles in simulation
     */
    std::vector<float> m_host_vel;
    std::vector<float> m_host_phase;

    // device(GPU) data
    /**
     * Users should not access or modify these data.
     * If you want to set a new scene for granular simulation, you should use the set...() methods in GranularParticleSolver.
     */
    float* m_device_pos;
    float* m_device_vel;

    float* m_external_force;

    // particle phase
    float* m_device_phase;
    bool   m_bInitialized;
    
    unsigned int m_num_particles;

    //neighbour copy
    float* m_neighbour;

    /**
     * @brief reset the granular component to the initial state
     */
    void reset();

    /**
     * @brief construction function of granular component
     *
     * @param[in] radius the radius of particles in simulation
     */
   
     PBDFluidComponent(float radius, float solid_cube_x, float solid_cube_y, float solid_cube_z);

     /**
      * @brief default construction function of PBDFluidComponent
      */
     PBDFluidComponent() = default;


    /**
     * @brief malloc memory for GPU data
     *
     * @param[in] numParticles the number of particles in simulation
     */
    void initialize(int numParticles);
    
    void addParticlePos(std::vector<float3>& pos, int phase);

    inline float frand()
    {
        return rand() / ( float )RAND_MAX;
    }
    /**
    * @brief free the cuda memory
    * You can also actively call it, and then use the initialize() function to allocate new GPU memory.
    * 
    *  You can also actively call it, and then use the initialize() function to allocate new GPU memory.
    *  Used for new scene creation, old scenes need to be destroyed. 
    *  Or when the simulation is over, this function would be called to free the GPU memory.
    */
    void freeMemory();
    /**
     * @brief destruction function of fluid component, free the GPU memory
     *
     * Using FluidParticleSolver::set...() methods instead of this function is recommended
     */
    ~PBDFluidComponent();
};

/**
 * Fluid solver. (Position based dynamics)
 * When create a Fluid solver, a default simulation parameter will automatically be created. Its parameters are tested and can run stably
 * But you can also modify some parameters through some function methods inside the class.
 *
 * This solver is used to simulate fluid particles.
 * Before using this solver, FluidComponent needs to be defined and successfully bound to this solver.
 * By modifying the parameters such as friction coefficient and stiffness coefficient in the solver,
 * the fine-tuning effect of particle phenomenon can be realized. The default params if used to simulate sand.
 *
 * the friction constrain and distance constrain are used to simulate the fluid particles.
 * An efficient parallel hash-grid (GREEN, S. 2008. Cuda particles. nVidia Whitepaper.) is implemented in this solver to accelerate the particle neighbor finding.
 */
class PBDFluidParticleSolver : public Solver
{
public:
    struct SolverConfig
    {
        double       m_dt{ 1.f / 60.f };          // Time step
        double       m_total_time{ 0.f };         // total time of simulation
        float        m_static_friction{ 1.f };    // Coefficient of static friction, used in friction constraint
        float        m_dynamic_friction{ 0.5f };  // Coefficient of dynamic friction, used in friction constraint
        float        m_stiffness{ 0.5f };         // Stiffness constant for the pressure forces in the SPH simulation
        float        m_gravity{ -9.8f };          // The acceleration due to gravity in the simulation
        float        m_sleep_threshold{ 0.02f };  // Velocity threshold below which particles are considered as 'sleeping'
        unsigned int m_solver_iteration{ 3 };     // Maximum number of iterations for the constraint solvera.
        float        m_sf_coeff{ 1.5f };            // Surface tension coeffcient between fluid & fluid particles
        float        m_adhesion_coeff{ 0.8f };    // Adhesion force coeffcient between fluid & solid/elastic particles
    };

    /**
     * @brief construction function of fluid solver
     */
    PBDFluidParticleSolver();

    /**
     * @brief destruction function of fluid solver
     */
    ~PBDFluidParticleSolver();

    /**
     * @brief initialize the fluid solver to get it ready for execution.
     *
     * @return  true if initialization succeeds, otherwise return false
     *
     */
    bool initialize() override;

    /**
     * @brief get the initialization state of the solver.
     *
     * @return   true if solver has been properly initialized, otherwise return false
     */
    bool isInitialized() const override;

    /**
     * @brief reset the solver to newly constructed state
     *
     * @return    true if reset succeeds, otherwise return false
     */
    bool reset() override;

    /**
     * @brief step the solver ahead through a prescribed time step. The step size is set via other methods
     *
     * @return    true if procedure successfully completes, otherwise return false
     */
    bool step() override;

    /**
     * @brief run the solver till termination condition is met. Termination conditions are set via other methods
     *
     * @return    true if procedure successfully completes, otherwise return false
     */
    bool run() override;

    /**
     * @brief check whether the solver is applicable to given object
     *        If the object contains fluid Components, it is defined as applicable.
     *
     * @param[in] object    the object to check
     *
     * @return    true if the solver is applicable to the given object, otherwise return false
     */
    bool isApplicable(const Object* object) const override;

    /**
     * @brief attach an object to the solver
     *
     * @param[in] object pointer to the object
     *
     * @return    true if the object is successfully attached
     *            false if error occurs, e.g., object is nullptr, object has been attached before, etc.
     */
    bool attachObject(Object* object) override;

    /**
     * @brief detach an object to the solver
     *
     * @param[in] object pointer to the object
     *
     * @return    true if the object is successfully detached
     *            false if error occurs, e.g., object is nullptr, object has not been attached before, etc.
     */
    bool detachObject(Object* object) override;

    /**
     * @brief clear all object attachments
     */
    void clearAttachment() override;

    /**
     * @brief set the simulation data and total time of simulation
     */
    void config(SolverConfig& config);

public:
    /**
     * @brief set the boundary of this simulator
     *
     * @param[in] lx  the lower boundary of the world in x direction
     * @param[in] ly  the lower boundary of the world in y direction
     * @param[in] lz  the lower boundary of the world in z direction
     * @param[in] ux  the upper boundary of the world in x direction
     * @param[in] uy  the upper boundary of the world in y direction
     * @param[in] uz  the upper boundary of the world in z direction
     *
     * @return    true if the boundary is successfully set
     */
    bool setWorldBoundary(float lx, float ly, float lz, float ux, float uy, float uz);

    /**
     * @brief set fluid particles' positions
     *
     * @param[in] host data of particle position array
     * @return true if position data is successfully set
     */
    bool setParticlePosition(const std::vector<float>& position);

    /**
     * @brief set fluid particles' velocity
     *
     * @param[in] host data of particle velocity array
     * @return true if velocity data is successfully set
     */
    bool setParticleVelocity(const std::vector<float>& velocity);

    /**
     * @brief set particle phase
     * In order to complete the coupling with other solver particles(such as the surface particles of vehicles),
     * we need to give fluid particles and other particles different phase. So that the fluid solver will not
     * solve other particles by mistake.
     *
     * @param[in] host data of particle velocity array
     * @return true if velocity data is successfully set
     */
    bool setParticlePhase(const std::vector<float>& particlePhase);

    /**
     * @brief set fluid particle external force
     *
     * @return true if force data is successfully set
     */
    bool setParticleExternalForce(float* external_force);

    /**
     * @brief get the device pointer of particle position
     *
     * float* particlePositionPtr = getParticlePositionPtr();
     * data layout: x, y, z, 1.0;
     *
     * @return the device pointer of particle position.
     *         nullptr if no valid object/component is attached to this solver.
     */
    float* getParticlePositionPtr();

    /**
     * @brief get the device pointer of particle velocity
     *
     * float* particleVelocityPtr = getParticleVelocityPtr();
     * data layout: x, y, z, 0.0;
     *
     * @return the device pointer of particle velocity.
     *         nullptr if no valid object/component is attached to this solver.
     */
    float* getParticleVelocityPtr();

    /**
     * @brief get the device pointer of particle Phase
     *
     * float* particlePhasePtr = getParticlePhasePtr();
     * data layout: Phase;
     *
     * @return the device pointer of particle Phase.
     *         nullptr if no valid object/component is attached to this solver.
     */
    float* getParticlePhasePtr();

    /**
     * @brief get the device pointer of particle external force
     *
     * float* particleExternalForcePtr = getParticleExternalForcePtr();
     * data layout: x, y, z;
     *
     * @return the device pointer of particle external force.
     *         nullptr if no valid object/component is attached to this solver.
     */
    float* getParticleExternalForcePtr();

    /**
    * @brief get the fluid particle radius. (eg: used for rendering or collision detect)
    * 
    * @param[out] particleRadius : the radius of fluid particle.
    * 
    */
    void getParticleRadius(float& particleRadius);

    /**
     * @brief set the fluid particle radius.
     *
     * @param[in] particleRadius : the radius of fluid particle. 
     * the value of particleRadius show be positive. 
     * If a negative or zero value is given, the value of particle_radius in simulation will not be changed.
     *
     */
    void setParticleRadius(const float& particleRadius);

    /**
     * @brief set static friction coefficient for particles
     *
     * @param[in] staticFriction : the static friction coefficient.
     * The value of the static friction coefficient should be between (0, 1].
     * Settings outside this range are invalid and and will be clamped to this range.
     */
    void setStaticFrictionCoeff(float& staticFriction);

    /**
     * @brief set static friction coefficient for particles
     *
     * @param[in] dynamicFriction : the static friction coefficient
     * The value of the dynamic friction coefficient should be between (0, 1].
     * Settings outside this range are invalid and and will be clamped to this range.
     */
    void setDynamicFrictionCoeff(float& dynamicFriction);

    /**
     * @brief set the stitffness coefficient of position based dynamics solver
     * If the stiffness is too large, simulation will be crash.
     *
     * @param[in] stiffness : Stiffness coefficient that determines the displacement of PBD particles
     * The value of the static Stiffness coefficient should be between (0, 1].
     * Settings outside this range are invalid and and will be clamped to this range.
     */
    void setStiffness(float& stiffness);

    /**
     * @brief Set the number of iterations for the position based dynamics solver
     *
     * @param[in] iteration : number of iterations, it cannot be negative. It should be greater than 0. (default value: 3)
     *
     * Increasing the number of iterations can make the simulation more stable.
     * And it can increase the initial accumulation height of sand to a certain extent.
     * Lowering it will reduce the pile height of the sand somewhat.
     *
     */
    void setSolverIteration(unsigned int& iteration);

    /**
     * @brief Set the gravity of the simulation
     *
     * @param[in] gravity : gravity in the world.(default value: -9,8)
     *
     * It is allowed to modify this parameter to any value as a extern force and lead to some interesting results.
     *
     */
    void setGravity(const float& gravity);

    /**
     * @brief Set the gravity of the simulation
     *
     * @param[in] x : extern force in x direction
     * @param[in] y : extern force in y direction
     * @param[in] z : extern force in z direction
     *
     * It is allowed to modify these parameter to any value as a extern force and lead to some interesting results.
     *
     */
    void setGravity(const float& x, const float& y, const float& z);

    /**
     * @brief Unified particle physics for real-time applications. (Section 4.5 Particle Sleeping.)
     *
     * Positional drift may occur when constraints are not fully satisfied at the end of a time-step.
     * We address this by freezing particles in place if their velocity has dropped below a user-defined threshold,
     *
     */
    void setSleepThreshold(float& threshold);

    /**
     * @brief set the world origin of the simulation
     *
     * @brief x: the x coordinate of the world origin
     * @brief y: the y coordinate of the world origin
     * @brief z: the z coordinate of the world origin
     *
     * For example: setWorldOrigin(0, 0, 0);
     * this worldOrigin will be used to calculate the hash value.
     *
     */
    void setWorldOrigin(const float& x, const float& y, const float& z);

    /**
     * @brief Set the surface-tension coeffcient of the simulation
     *
     * @param[in] gravity : gravity in the world.(default value: 1.5)
     *
     * The value on 1.5f is used to simulate hydrophilic/hydrophobic effect. General fluid simulation should use a lower value.
     *
     */
    void setSFCoeff(const float& sfcoeff);

    /**
     * @brief Set the adhesion force between fluid & solid/elastic of the simulation
     *
     * @param[in] gravity : gravity in the world.(default value: 0.4)
     *
     */
    void setAdhesionCoeff(const float& AdhesionCoeff);

protected:
    /**
     * @brief Handle the collision between particles and other objects
     *
     * @param[in] collision_particle_id : the id of the particle which collides with other objects
     * @param[in] moveDirection : the direction of the particle movement
     * @param[in] moveDistance :  the distance of the particle movement
     * @param[in] collision_num : the number of particles which collide with other objects
     *
     */
    void handleCollision(unsigned int* collision_particle_id, float* moveDirection, float* moveDistance, unsigned int collision_num);

    /**
     * @brief destroy the solver
     */
    void _finalize();

    /**
     * @brief write the particles data to ply file
     */
    void writeToPly(const int& step_id);

    /**
     * @brief free particle memory
     */
    void freeParticleMemory(const int& numParticles);

    /**
     * @brief malloc particle memory
     */
    void mallocParticleMemory(const int& numParticles);

private:
    Object*                 m_fluid_particle;
    unsigned int*           m_collision_particle_id;
    bool                    m_is_init;
    double                  m_cur_time;
    SolverConfig            m_config;
    PBDFluidSimulateParams* m_params;
    float*                  m_host_pos;
    float*                  m_host_phase;

private:
    // GPU parameters
    // semi-lagrangian advect
    float* m_device_delta_pos;
    float* m_device_predicted_pos;
    // hash neighbour search
    unsigned int* m_device_cell_start;
    unsigned int* m_device_cell_end;
    unsigned int* m_device_grid_particle_hash;
    unsigned int  m_num_grid_cells;
    unsigned int  m_num_particles;
};

}  // namespace Physika

#endif  // PHYSIKA_FLUID_SOLVER_H