## 命名约定
* 通用命名规则
  * 命名原则
    * 简洁固然重要，但名字应该更注重无歧义、清晰、明确。不要节约行空间，让开发者（包括自己）能第一时间理解代码更为重要。
  * 缩写
    * 函数命名，变量命名， 文件命名应具备准确描述性，不要过度缩写。除非该缩写在其它地方都非常普遍, 否则不要使用。
* 文件及文件夹命名
  * 文件后缀
    * C++源码文件：.cpp
    * C++头文件：.hpp
    * 纯C头文件（如接口文件）：.h
    * 头文件实现文件（如模板实现）：.inl
  * 文件命名
    * 小写 + 下划线，例：sparse_matrix.hpp
  * 文件编码
    * 所有源文件必须使用UTF-8编码，避免乱码问题
  * 文件夹命名
    * 小写 + 下划线
* 类型命名
  * 每个单词首字母均大写, 不包含下划线。类型名一般为具有准确描述性的名词，而非使用动词。
* 变量命名
  * 普通变量：小写 + 下划线
  * 类/结构体成员变量：以“m_”前缀开始，小写 + 下划线。例如：m_member
    * 对于有特殊设计的类/结构体，如Vec3包含变量x,y,z 并且特意设计为 public，,其命名经慎重考虑可以不遵循上述规则。
  * 全局变量：以“g_“前缀开始，小写 + 下划线。
  * 常量/枚举/宏：字母全部大写，单词用下划线连接，结尾不用_。例如：FIRST_TYPE。
* 函数命名
  * 常规函数和取值设置函数统一风格，均采用首个单词小写，后面单词首字母大写，若只有一个单词，小写即可。函数命名不用下划线。
  * 一般而言，函数名通常是指令性的，首个单词一般为动词，如设值函数为set+变量名，同样参照大小写。取值函数则直接用变量名。
## 代码风格
* 自动格式化
  * 项目目录中附带了clang-format的配置文件（.clang-format），各开发者应安装clang-format程序，并在提交代码前执行clang-format程序进行代码格式化（可配置代码编辑器在保存时自动格式化）。
* 头文件
  * 头文件保护：以下两种方式都被允许。
    * 头文件保护宏：为保证唯一性，头文件保护的命名格式应该依据所在项目源代码树的全路径： PROJECT_PATH_FILE_H_
    * 预编译指令：#pragma once
  * include顺序
    * 与 .cpp对应的.hpp（如 a.cpp 对应 a.hpp）
    * 空行
    * C库
    * C++库
    * 空行
    * 其他库的 .hpp/.h
    * 本项目内其他的 .hpp/.h
  * 严禁底层头文件 #inlucde 顶层模块的头文件，否则容易产生循环依赖。
  * 项目内头文件应按照项目源代码目录树结构排列, 避免使用UNIX 特殊的快捷目录 .(当前目录) 或 .. (上级目录)。最好不使用同文件夹下的相对目录。包含相同文件夹下的头文件最好不需要从include根目录写起。
  * 前置声明：尽可能使用前置声明，只include必要的头文件。
* 作用域
  * 命名空间
    * 顶层命名空间为namespace Physika
    * 用命名空间把除文件包含以及外部类的前置声明以外的整个源文件封装起来，以区别于其他命名空间。
    * 命名空间不需要添加任何缩进，且大括号位于命名空间的后面，添加一个空格隔开，其中的类以及函数都每行开始不需要缩进。
    * 任何时候都尽量避免using整个命名空间，在头文件中谨慎使用using声明，造成命名空间污染。
  * 局部变量
    * 在尽可能小的作用域中声明变量，并在变量声明时进行初始化，离第一次使用越近越好。
  * 静态和全局变量
    * 不推荐使用静态和全局变量，类的静态成员变量除外。
* 类
  * 类声明及成员顺序
    * 在类中按照存取控制权限声明顺序：public、protected、private
    * 每个区段内的声明通常按以下顺序：
      * typedef和枚举
      * 常量
      * 构造函数
      * 析构函数
      * 成员函数, 含静态成员函数
      * 数据成员, 含静态数据成员
    * 为区别成员函数和数据成员，关键字（如 private）可以多次使用。
  * 构造函数
    * 当构造函数仅有一个参数时, 除非特意设计，务必将“单参量构造函数”声明为explicit，禁用隐式类型转换。
    * 禁止在构造函数中调用虚函数。
    * 如果类数据成员非常多，并且存在多个构造函数，建议使用C++11及以后标准的委托构造函数功能。
  * 析构函数函数
    * 当类作为多态基类使用时，即类包含虚函数时。请务必将析构函数声明为virtual，保证类对象能够正确析构。
    * 禁止在析构函数中调用虚函数。
    * 禁止在析构函数中抛出异常。
  * 若要禁止编译器自动生成某些函数（如默认构造函数、拷贝构造函数等），使用C++ 11提供的delete函数特性，而非将这些函数声明为private且不提供定义的方式。
  * 类继承
    * 继承深度不允许超过2，即一个类至多只能继承到“孙子类”。
  * 虚函数
    * 若要覆写基类的虚函数，请显式添加 override 关键字进行声明。
  * 访问权限控制
    * 将所有数据成员声明为 private/protected, 并根据需要提供相应的存取函数。
  * 友元
    * 不建议使用友元。
  * 类 vs 结构体
    * 仅当只有数据时使用struct, 即POD(plain of data)，其它一概使用class。
  * 枚举类
    * 当定义枚举类型时，请使用enum class 而不是enum。
* 函数
  * 倾向编写简短, 凝练的函数。如果函数超过40行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割。
  * 函数参数顺序：输入参数、输入/输出参数、输出参数。
  * 函数重载
    * 若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种。这一规则也适用于构造函数。
  * 默认参数
    * 不建议使用默认参数。
  * 函数返回类型后置语法
    * 只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法。
  * 内联函数
    * 函数声明为内联函数的时候要谨慎，只对那些展开代码很少，并且不包含循环或者判断条件的代码，才声明其为内联函数。
    * 为保证类定义的整洁性，不应将内联函数实现在类定义的内部，而应该实现于同一头文件的类定义的外部。
* 语句
  * 条件语句
    * 条件语句如果某个分支使用了大括号，所有分支都需要使用大括号。
    * 对于短小的单行条件语句，最好不使用大括号。如果条件判断非常长，需写成多行，为避免“头重脚轻”，推荐使用大括号。如果单行语句特别长，需要折断写成多行，则也应该使用大括号。
    * 编写条件语句时，请将正常情况的处理放在if后面而不要放在else后面，保证正常情况的执行路径在代码中是清晰的。这对可读性和代码性能来说非常重要。
  * switch语句
    * switch 的分支如果不是没有语句的case，都必须包含break。
    * switch 语句必须有default分支，并且在不可能到达的分支使用 assert，或者进行适当的错误处理。
  * 空循环语句
    * 空循环体应使用 {} 或 continue，以增强可读性。
  * 避免深层嵌套
    * 无论是对于条件语句还是循环语句，避免使用超过3到4层的嵌套，否则将会严重降低代码的可理解性。一般可以对代码重构，简化代码结果，或者将深层嵌套提取为函数。
* 变量&表达式
  * auto变量定义
    * 尽量在不影响代码可读性情形下使用 auto 自动类型推导。
  * 整型变量定义
    * 强烈推荐对于用于运算的整型变量，使用 int8_t, int16_t, int32_t, int64_t 等定宽类型，而非 char, short, int, long, long long 等类型。因为 C++ 标准只规定这些类型的最小位数，不保证内置类型一定具有 16/32/64 位。
    * 不允许用char类型做数值运算。
  * 无符号数vs有符号数
    * 谨慎使用无符号数，避免下溢风险。
    * 算术运算不要混用有符号类型和无符号类型，最好使用有符号类型。
    * 对于位运算和取模运算，使用无符号类型是合理的。
    * 如果不涉及算术运算（如只用来遍历），使用无符号类型可能是合理的（如为适应STL）。
    * 如果涉及算术运算（整型提升），直接选择使用有符号数可能更为合适。
  * sizeof
    * 尽可能使用sizeof(varname)代替sizeof(type)，以减少代码修改不全造成的潜在问题。
* 其他C++特性
  * C++标准
    * 支持使用C++17标准
  * （显式）强制类型转换
    * 使用 C++ 的类型的显式强制转换, 如 static_cast<>()。
    * 禁止使用C风格的转换。
  * 类型别名
    * 使用using别名声明，不建议使用typedef。
  * const/constexpr的使用
    * 强烈建议在任何可能的情况下都要使用 const/constexpr。
  * 预处理宏
    * 不建议使用，尽量以内联函数, 枚举和常量代替之。
  * 空指针
    * 使用 C++11 中的nullptr 来代表空指针，而不是使用 NULL/0 来表示。
  * 智能指针
    * 推荐使用 C++ 11 提供的智能指针来自动管理内存和资源，实施所谓的 RAII （资源获取就是初始化）和异常安全。
  * Lambda表达式
    * 适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来。
  * std::function vs 函数指针
    * 推荐使用 std::function 来传递函数（可调用对象），而非裸函数指针。
  * assert语句
    * 尽量考虑代码的鲁棒性，对函数参数及用户行为不要做过多的假设，必要时使用assert语句，便于调试。这也是防御式编程的重要手段。
    * 如项目提供自定义的assert语句，使用项目提供的，而非c++默认的。
  * Warning相关
    * 所有代码应该以无警告、干净的方式通过编译。
    * 不允许在代码中通过编译器指令忽略警告。
  * 异常
    * 尽量避免使用异常，通过使用状态码+检查机制来进行错误处理。
* 注释
  * 注释固然很重要，但最好的代码本身应该是自文档化。有意义的类型名和变量名，要远胜过要用注释解释的含糊不清的名字。
  * 使用英文注释，以避免字符编码问题。
  * 注释应该简洁，并能准确描述所应说明内容。
  * 注释风格参考Doxygen。
  * 文件注释
    * 无论是在头文件还是在实现文件中，都使用统一的文件头
    ```C++
    /**
     * @author     : Zhu Fei (zhufei@simversus.com)
     * @date       : 2023-03-08
     * @description: declaration of World class, which is a library-scope manager
     * @version    : 1.0
     */
    ```
  * 类注释
    * 每个类的定义都要附带一份注释，描述类的功能和用法。
  * 函数注释
    * 函数注释位于声明之前，对函数功能及用法进行描述。通常，注释不会描述函数如何工作，那是函数定义部分的事情。
    ```C++
    /**
    * implementation of doSometing
    *
    * @param[in]      in      parameter to read only
    * @param[in,out] in_out parameter to read and write
    * @param[out]     out     parameter to write only
    */
    ```
  * 变量注释
    * 通常变量名足以很好说明变量用途。
    * 每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途。
    * 成员变量的注释直接在后面使用 //!< 来实现
  * 实现注释
    * 对于代码中巧妙、晦涩、有趣、重要的地方要加注释。
  * 字面值函数实参
    * 向函数传入字面常量值时（如NULL、rue/false、123）时, 要注释说明含义, 或使用常量让代码望文知意。
  * TODO和NOTE注释
    * 对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 TODO 注释。
    * TODO 注释要使用全大写的字符串 TODO, 在随后的圆括号里写上你的大名, 邮件地址, 或其它身份标识。
    * 添加 TODO 注释并不意味着你要自己来修正。
    * 对于需要代码阅读者（包括自己）尤其注意的地方，可以使用NOTE 注释，同样需要在圆括号里面写上你的大名。
  * 避免无意义注释








